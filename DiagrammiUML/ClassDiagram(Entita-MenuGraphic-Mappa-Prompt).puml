@startuml
package "Entita'" #DDDDDD{ /'ADT tutti tipi di entità '/
enum MType{
  MOSTRO_MARINO
  COBOLDO
  BOSS_DRAGO
  ARMATURA
  MAGO_OSCURO
}

abstract class Entity{
  Inventario inv;
  String name;
  String history;
  short health;
  short maxHealth;
  byte damage;
  byte armor;
  byte level;

  /'---------- METODI ENTITY ----------'/
  byte getLv();
  byte getLife();
  byte getMaxLife();
  String getHistory();
  String getName();
  byte getDamage();
  byte getArmor();
  Inventario getInv();
  String showInv();
  short changeHealth(short value);
  abstract void setLv(byte l);
  abstract boolean addItem(ItemStack i);
  abstract boolean removeItem(ItemStack i)

  protected void safeIncrementHealth(short amount);
  protected void safeIncrementDamage(byte amount);
  protected void safeIncrementArmor(byte amount);
  protected void safeDecrementHealth(short amount);
  protected void safeDecrementDamage(byte amount);
  protected void safeDecrementArmor(byte amount);
} 



class Player{
  private PropertyChangeSupport observerHandler;
  final byte MAX_INVENTORY_WEIGHT = 10
  final byte BASE_DAMAGE = 1
  final byte BASE_ARMOR = 1
  final byte BASE_HEALTH = 5
  final byte BASE_LEVEL = 1
  final byte HEALTH_MULTIPLIER = 2
  final byte DAMAGE_MULTIPLIER = 1
  final byte ARMOR_MULTIPLIER = 1
  final String story = ""

  /'---------- COSTRUTTORI ----------'/
  Player(String name);
  /'---------- METODI PLAYER ----------'/
  void addObserver(PropertyChangeListener listener);
  void removeObserver(PropertyChangeListener listener);
  boolean doesFillInv(ItemStack i);
}

abstract class Monster{
  private MType type
  private final byte BASE_DAMAGE = 2
  private final byte BASE_ARMOR = 1
  private final byte BASE_HEALTH = 3
  private final byte BASE_LEVEL = 1
  private final byte HEALTH_MULTIPLIER = 2
  private final byte DAMAGE_MULTIPLIER = 1
  private final byte ARMOR_MULTIPLIER = 1

  /'---------- COSTRUTTORI ----------'/
  Monster(MType t, String name);
  Monster(MType t, String name, short health, byte damage, byte armor);
  /'---------- METODI MONSTER ----------'/
  void propertyChange(PropertyChangeEvent event);
  private String selectName(MType t);
  MType getType();
}
class MonsterFactory{
  /'---------- METODI MONSTER_FACTORY ----------'/
  Monster create(MType type);
  Monster create(MType t, String name);
  Monster create(MType t, String name, short health, byte damage, byte armor);
  Monster createRandom();
}
class Armatura{
  final String story="";

  /'---------- COSTRUTTORI ----------'/
  Armatura();
  Armatura(String name);
  Armatura(String name, short health, byte damage, byte armor);
}
class MagoNero{
  final String story="";

  /'---------- COSTRUTTORI ----------'/
  MagoNero();
  MagoNero(String name);
  MagoNero(String name, short health, byte damage, byte armor);
}
class MostroMarino{
  final String story="";

  /'---------- COSTRUTTORI ----------'/
  MostroMarino();
  MostroMarino(String name);
  MostroMarino(String name, short health, byte damage, byte armor);
}
class Coboldo{
  final String story="";

  /'---------- COSTRUTTORI ----------'/
  Coboldo();
  Coboldo(String name);
  Coboldo(String name, short health, byte damage, byte armor);

}
class BossDrago{
  final String story="";

  /'---------- COSTRUTTORI ----------'/
  BossDrago();
  BossDrago(String name);
  BossDrago(String name, short health, byte damage, byte armor);
}

}
Monster -> MType
Player --|>Entity
Monster --|>Entity
Armatura--|> Monster
MagoNero --|> Monster
MostroMarino --|> Monster
Coboldo--|> Monster
BossDrago--|> Monster

MonsterFactory --> BossDrago
MonsterFactory --> MagoNero 
MonsterFactory --> Coboldo
MonsterFactory --> Armatura
MonsterFactory --> MostroMarino 

/'sta nel kernel layer'/
package MenuGraphic #DDDDDD{
class LoaderMenu{
  LoaderMenu(String file)
  Menu getMenu();

}

abstract class Menu{
  /'La prima stringa e il comando mentre la seconda è la descrizione'/
  Map<String, String> commandMap = new HashMap<String, String>;
  
  Vector<String> getElement();
  String toString();
}
class StartMenu{}
class BattleMenu{}
class MovmentMenu{}
class ExitMenu{}
}
note left of Menu :"Specificare i singoli comnadi nelle implementazioni dei menù"
BattleMenu---|> Menu
StartMenu---|> Menu
MovmentMenu ---|> Menu
ExitMenu---|> Menu

BattleMenu --> LoaderMenu
StartMenu --> LoaderMenu
MovmentMenu --> LoaderMenu
ExitMenu --> LoaderMenu


package Mappa #DDDDDD{   

class LoaderMap{
  LoaderMap(String file);
  MapGraf getMap();
} 
    
class Coordinates{
  int x,y;
  int getX();
  int getY();
  int setX();
  int setY();

}
  /'Classe che carica da file la lista dei nodi'/
  class LoadNode{
  List<node> list = new ArrayList<node>;
  public LoadNode(String fileName);
  
  List<node> getListCommands();
  
}

  class MapGraf{
  List<Stanza> stanze = new ArrayList<Stanza>;
  /*Questa classe implementa un red-black tree*/
  TreeMap<K,node> nodiTree = new TreeMap<K,V>;

  generateStanze();
  generatePercorso();
  /'Converte la lista di nodi in un albero'/
  listToTree(List<node> l);
  List<node> getPercorsoTo(Nodo start, Stanza end);
  List<Direction> validPositionOf(node n);
  boolean checkpositionOf(node n);
  
  
}
note left of MapGraf :"Classe di facade"

enum  Direction{
  NORD
  WEST
  OVEST
  SOUTH
}

class node
{
  Coordinates cord;
  Direction[] dir = new Direction[4];
  setDirection(Direction[] d);
  addDirection(Direction d);
  Direction[] getDirection();

}
   class Stanza{
  Coordinates cord;
  Monster mostro;
  setCord(int x, int y);
  Coordinates getCord();
  Chest baule;
  Monster getMostro();
  Chest getChest();
}

} 


MapGraf "1"--> "*" Stanza
MapGraf "1"--> "1" LoadNode
MapGraf "1" --> "*" node
node"1" --> "1"Coordinates
node"1" --> "1"Direction
Stanza"1" --> "1"Coordinates


package Prompts #DDDDDD{
/'Questa class è un Singleton: tutto entra ed esce da qua'/
class Promt{
  Command cmmd;
  boolean egnineLinked;
  
  /'----------- COSTRUTTORI -----------'/
  Promt();
  /'----------- METODI PROMPT -----------'/
  private void changeCommand(Command c);
  void linkEngine(GameEngine g)
  InputType waitInput();
}

class StartCommand{
  execute();
}
class ExitCommand{
  execute();
}
class LookCommand{
  execute();
}
class AttackCommand{
  execute();
}
class MoveBackCommand{
  execute();
}
class MovePlayerCommand{
  execute();
}
class PlayerTakeCommand{
  execute();
}
class PlayerUseCommand{
  execute();
}
class PlayerRemoveCommand{
  execute();
}
class PlayerRemoveStackCommand{
  execute();
}
class LoadCommand{
  execute();
}

interface Command{
  execute();
}

}
StartCommand --|> Command
ExitCommand --|> Command
LookCommand --|> Command
AttackCommand --|> Command
MoveBackCommand --|> Command
MovePlayerCommand --|> Command
PlayerUseCommand --|> Command
PlayerRemoveStackCommand --|> Command
LoadCommand --|> Command
Promt --> Command

@enduml