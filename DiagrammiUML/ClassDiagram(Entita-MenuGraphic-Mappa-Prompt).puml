@startuml
package "Entita'" #DDDDDD{ /'ADT tutti tipi di entità '/
enum MType{
  MOSTRO_MARINO
  COBOLDO
  BOSS_DRAGO
  ARMATURA
  MAGO_OSCURO
}

abstract class Entity{
  String name;
  String history;
  short health;
  short maxHealth;
  byte attack;
  byte armor;
  byte level;

  /'---------- METODI ENTITY ----------'/
  byte getLv();
  byte getLife();
  byte getMaxLife();
  String getHistory();
  String getName();
  byte getAttack();
  byte getArmor();
  short changeHealth(short value);
  abstract void setLv(byte l);

  protected void safeIncrementHealth(short amount);
  protected void safeIncrementDamage(byte amount);
  protected void safeIncrementArmor(byte amount);
  protected void safeDecrementHealth(short amount);
  protected void safeDecrementDamage(byte amount);
  protected void safeDecrementArmor(byte amount);
} 



class Player{
  private PropertyChangeSupport observerHandler;
  Inventario inv;
  final byte MAX_INVENTORY_WEIGHT = 10
  final byte BASE_ATTACK= 1
  final byte BASE_ARMOR = 1
  final byte BASE_HEALTH = 5
  final byte BASE_LEVEL = 1
  final byte HEALTH_MULTIPLIER = 2
  final byte DAMAGE_MULTIPLIER = 1
  final byte ARMOR_MULTIPLIER = 1
  final String story = ""

  /'---------- COSTRUTTORI ----------'/
  Player(String name);
  /'---------- METODI PLAYER ----------'/
  void addObserver(PropertyChangeListener listener);
  void removeObserver(PropertyChangeListener listener);
  void setLv(byte l);
  boolean doesFillInv(ItemStack i);
  boolean removeItem(ItemStack i);
  boolean addItem(ItemStack i);
  Inventario getInv();
  String showInv();
}

abstract class Monster{
  private MType type
  private final byte HEALTH_MULTIPLIER = 2
  private final byte DAMAGE_MULTIPLIER = 1
  private final byte ARMOR_MULTIPLIER = 1

  /'---------- COSTRUTTORI ----------'/
  Monster(MType t, short baseHealth, byte baseDamage, byte baseArmor, byte baseLv , byte healthMul, byte damageMul, byte armorMul);
  Monster(MType t, String name, short baseHealth, byte baseAttack, byte baseArmor, byte baseLv, byte healthMul, byte damageMul, byte armorMul);
  /'---------- METODI MONSTER ----------'/
  void propertyChange(PropertyChangeEvent event);
  private String selectName(MType t);
  MType getType();
  void setLv(byte l);
}
class MonsterFactory{
  /'---------- METODI MONSTER_FACTORY ----------'/
  Monster create(MType type);
  Monster create(MType t, String name);
  Monster create(MType t, String name, short health, byte damage, byte armor);
  Monster createRandom();
}

class xmlReader{
  /'---------- COSTRUTTORI ----------'/
  xmlReader(String fileName)

  /'---------- METODI----------'/
  Vector<MonsterValues> getMonsterValues();
  private MonsterValues getValuesFrom(Element eAttribute);
  private MType getMTypeBy(String name);
}

class MonsterValues{
  short health, maxHealth;
  byte damage, armor, level;
  byte healthMul, armorMul, damageMul;
}

note right of MonsterValues:"è una struct"


class Armatura{
  final String story="";

  /'---------- COSTRUTTORI ----------'/
  Armatura();
  Armatura(String name);
  Armatura(String name, short health, byte damage, byte armor);
}
class MagoNero{
  final String story="";

  /'---------- COSTRUTTORI ----------'/
  MagoNero();
  MagoNero(String name);
  MagoNero(String name, short health, byte damage, byte armor);
}
class MostroMarino{
  final String story="";

  /'---------- COSTRUTTORI ----------'/
  MostroMarino();
  MostroMarino(String name);
  MostroMarino(String name, short health, byte damage, byte armor);
}
class Coboldo{
  final String story="";

  /'---------- COSTRUTTORI ----------'/
  Coboldo();
  Coboldo(String name);
  Coboldo(String name, short health, byte damage, byte armor);

}
class BossDrago{
  final String story="";

  /'---------- COSTRUTTORI ----------'/
  BossDrago();
  BossDrago(String name);
  BossDrago(String name, short health, byte damage, byte armor);
}

}
Monster -> MType
Player --|>Entity
Monster --|>Entity
Armatura--|> Monster
MagoNero --|> Monster
MostroMarino --|> Monster
Coboldo--|> Monster
BossDrago--|> Monster

MonsterFactory --> BossDrago
MonsterFactory --> MagoNero 
MonsterFactory --> Coboldo
MonsterFactory --> Armatura
MonsterFactory --> MostroMarino 
MonsterFactory -> xmlReader
xmlReader -> MonsterValues


/'sta nel kernel layer'/
package MenuGraphic #DDDDDD{
class LoaderMenu{
  LoaderMenu(String file)
  Menu getMenu();

}

abstract class Menu{
  /'La prima stringa e il comando mentre la seconda è la descrizione'/
  Map<String, String> commandMap = new HashMap<String, String>;
  
  Vector<String> getElement();
  String toString();
}
class StartMenu{}
class BattleMenu{}
class MovmentMenu{}
class ExitMenu{}
}
note left of Menu :"Specificare i singoli comnadi nelle implementazioni dei menù"
BattleMenu---|> Menu
StartMenu---|> Menu
MovmentMenu ---|> Menu
ExitMenu---|> Menu

BattleMenu --> LoaderMenu
StartMenu --> LoaderMenu
MovmentMenu --> LoaderMenu
ExitMenu --> LoaderMenu


package Mappa #DDDDDD{   

class LoaderMap{
  /'---------- COSTRUTTORI ----------'/
  LoaderMap(String file);

  /'---------- METODI----------'/
  Graph<Node, edge> getMap();
} 
    
class Coordinates{
  int x,y;
  
  /'---------- COSTRUTTORI ----------'/
  Coordinates(int x, int y);

  /'---------- METODI----------'/
  int getX();
  int getY();
  int setX(int x);
  int setY(int y);

}

class MapGraph{
  ArrayList<Room> rooms = new ArrayList<Room>;
  Graph<Node, edge> nodiTree = new Graph<Node, edge>;

  /'---------- METODI ----------'/
  private ArrayList<Room> generateRoom(int quantity);

  List<node> getRouteTo(Coordinates start, Coordinates end);
  Direction[] validDirectionOf(Coordinates n);
  boolean isValidDirectionFor(Coordinates n, Direction dir);
  Monster getMonsterAt(Coordinates cord);
  Chest getChestAt(Coordinates cord);
}
note left of MapGraph :"Classe di facade"

enum  Direction{
  NORD
  WEST
  OVEST
  SOUTH
}

class node{
  Coordinates cord;
  Direction[] dir;
  
  /'---------- COSTRUTTORI ----------'/
  node(Direction[] dir);

  /'---------- METODI ----------'/
  setDirection(Direction[] d);
  addDirection(Direction d);
  Direction[] getDirection();

}

class Room{
  Coordinates cord;
  Monster monster;
  Chest chest;
  
  /'---------- COSTRUTTORI ----------'/
  Room(int x, int y);

  /'---------- METODI ----------'/
  Coordinates getCord();
  Monster getMonster();
  Chest getChest();
  }

} 


MapGraph --> Room
MapGraph --> node
MapGraph -> LoaderMap
node --> Coordinates
node --> Direction
Room --> Coordinates


package Prompts #DDDDDD{
/'Questa class è un Singleton: tutto entra ed esce da qua'/
class Promt{
  Command cmmd;
  boolean egnineLinked;
  
  /'----------- COSTRUTTORI -----------'/
  Promt();
  /'----------- METODI PROMPT -----------'/
  private void changeCommand(Command c);
  void linkEngine(GameEngine g)
  BackStateGame_Enum waitInput();
}

class StartCommand{
  execute();
}
class ExitCommand{
  execute();
}
class LookCommand{
  execute();
}
class AttackCommand{
  execute();
}
class MoveBackCommand{
  execute();
}
class MovePlayerCommand{
  execute();
}
class PlayerTakeCommand{
  execute();
}
class PlayerUseCommand{
  execute();
}
class PlayerRemoveCommand{
  execute();
}
class PlayerRemoveStackCommand{
  execute();
}
class LoadCommand{
  execute();
}

interface Command{
  execute();
}

}
StartCommand --|> Command
ExitCommand --|> Command
LookCommand --|> Command
AttackCommand --|> Command
MoveBackCommand --|> Command
MovePlayerCommand --|> Command
PlayerUseCommand --|> Command
PlayerRemoveStackCommand --|> Command
LoadCommand --|> Command
Promt --> Command

@enduml
